<?xml version="1.0"?>
<!DOCTYPE gsdoc PUBLIC "-//GNUstep//DTD gsdoc 0.6.6//EN" "http://www.gnustep.org/gsdoc-0_6_6.xml">
<gsdoc base="NSFunctions" up="Base">
  <head>
    <title>NSFunctions</title>
    <author name="Richard Frith-Macdonald">
      <email address="rfm@gnu.org"/>
      <url url="http://www.gnustep.org/developers/whoiswho.html"/>
    </author>
    <version>$Revision$</version>
    <date>$Date$</date>
  </head>
  <body>
    <chapter>
      <heading>Functions</heading>
      <function name="GSCurrentThread" type="NSThread*">
        <declared>Foundation/NSThread.h</declared>
	<desc>
	  <p>
	    This function is a GNUstep extension.  It pretty much
	    duplicates the functionality of [NSThread +currentThread]
	    but is more efficient and is used internally throughout
	    GNUstep.
	  </p>
	  <p>
	    Returns the current thread.  Could perhaps return <code>nil</code>
	    if executing a thread that was started outside the GNUstep
	    environment and not registered (this should not happen in a
	    well-coded application).
	  </p>
	</desc>
	<standards><NotOpenStep/><NotMacOS-X/><GNUstep/></standards>
      </function>

      <function name="GSRegisterCurrentThread" type="BOOL">
        <declared>Foundation/NSThread.h</declared>
	<desc>
	  <p>
	    This functiion is provided to let threads started by some other
	    software library register themselves to be used with the
	    GNUstep system.  All such threads should call this function
	    before attempting to use any GNUstep objects.
	  </p>
	  <p>
	    Returns <code>YES</code> if the thread can be registered,
	    <code>NO</code> if it is already registered.
	  </p>
	  <p>
	    Sends out a <code>NSWillBecomeMultiThreadedNotification</code>
	    if the process was not already multithreaded.
	  </p>
	</desc>
	<standards><NotOpenStep/><NotMacOS-X/><GNUstep/></standards>
      </function>

      <function name="GSUnregisterCurrentThread" type="void">
        <declared>Foundation/NSThread.h</declared>
	<desc>
	  <p>
	    This functiion is provided to let threads started by some other
	    software library unregister themselves from the GNUstep threading
	    system.
	  </p>
	  <p>
	    Calling this function causes a
	    <code>NSThreadWillExitNotification</code>
	    to be sent out, and destroys the GNUstep NSThread object
	    associated with the thread.
	  </p>
	</desc>
	<standards><NotOpenStep/><NotMacOS-X/><GNUstep/></standards>
      </function>
    </chapter>

    <chapter>
      <heading>Types</heading>
      <type name="NSRange">
	<typespec>
	  struct { unsigned long location; unsigned long length; }
	</typespec>
        <declared>Foundation/NSRange.h</declared>
	<desc>
	  <p>
	    The NSRange type is used to specify ranges of locations,
	    typically items in an array, characters in a string, and bytes
	    in a data object.
	  </p>
	  <p>
	    As 'boundary' or 'fencepost' errors are a particularly common
	    problem in programming, it is important that you understand
	    how an NSRange works.
	  </p>
	  <p>
	    An NSRange consists of a location and a length.  The points
	    that are considered to lie in a range are the integers from
	    the location to the location plus the length, so the number
	    of points in a range is the length of the range plus one.<br />
	    However, if you consider these points like the marks on a
	    ruler, you can only store information <strong>between</strong>
	    points.  So the number of items that can be stored in a range
	    is the length of the range.
	  </p>
	</desc>
	<standards><OpenStep/><MacOS-X/><GNUstep/></standards>
      </type>
    </chapter>
  </body>
</gsdoc>
